# Authors: Christian O'Reilly <christian.oreilly@sc.edu>
#          Scott Huberty <seh33@uw.edu>
# License: MIT

"""class to wrap mne.annotations in dash shapes/annotations."""

import mne
import numpy as np
import pandas as pd
from uuid import uuid1


class EEGAnnotation:
    """Store mne.annotation info as plotly shapes & annotation."""

    def __init__(self, onset, duration, description_str, layout):
        """Initialize instance of class.

        Parameters
        ----------
        onset : int | float
            onset time of annotation in seconds relative to recording start.
        duration: int | float
            duration of annotation in seconds.
        description_str : str
            description of the annotation event, such as "blink".
            descriptions beginning with "bad_" will be considered as
            time durations to be excluded by mne-python.
        layout : plotly.graph_objects.layout
            The graph layout object that the annotations should be
            plotted onto.
        """
        self._id = str(uuid1())
        self._onset = onset
        self._duration = duration
        self._description = description_str

        self._dash_layout = layout
        self._dash_shape = dict(name=self.id,
                                type="rect",
                                xref="x",
                                yref="y",
                                x0=self.onset,
                                y0=self._dash_layout.yaxis['range'][0],
                                x1=self.onset + self.duration,
                                y1=self._dash_layout.yaxis['range'][1],
                                fillcolor='red',
                                opacity=0.25 if self.duration else .75,
                                line_width=1,
                                line_color='black',
                                layer="below" if self.duration else 'above')
        self._dash_description = dict(x=self.onset + self.duration / 2,
                                      y=self._dash_layout.yaxis['range'][1],
                                      text=self.description,
                                      showarrow=False,
                                      yshift=10,
                                      font={'color': '#F1F1F1'})

    def update_dash_objects(self):
        """Update plotly shape/annotations.

        Notes
        -----
        _dash_shape holds the shape made from the mne.annotation.
        plotly.graph_objects.layout.shape objects cannot have text, so
        _dash_description is a plotly.graph_objects.layout.annotation and
        contains the mne.annotation.description.
        """
        self._dash_shape["x0"] = self.onset
        self._dash_shape["x1"] = self.onset + self.duration
        self._dash_shape["opacity"] = 0.25 if self.duration else .75

        self._dash_description["x"] = self.onset + self.duration / 2
        self._dash_description["text"] = self.description

    def to_mne_annotation(self):
        """Convert plotly shape/annotation info into mne.annotation."""
        return mne.Annotations(self.onset, self.duration, self.description)

    @property
    def id(self):
        """Return the unique ID of the instance of this class.

        Notes
        -----
        this id is generated by uuid1 from the standard library.
        The ID is a long string. It is used to keep track of a shape/annotation
        in the event that it is deleted or modified by the user. this ID is
        stored in the name parameter of its respective shape and annotation.
        """
        return self._id

    @property
    def dash_shape(self):
        """Return the plotly shape associated with this instance."""
        return self._dash_shape

    @property
    def dash_description(self):
        """Return the plotly.graph_objects.layout.annotation."""
        return self._dash_description

    @property
    def onset(self):
        """Return the onset for this instance."""
        return self._onset

    @onset.setter
    def onset(self, onset):
        self._onset = onset
        self.update_dash_objects()

    @property
    def duration(self):
        """Return the duration for this instance."""
        return self._duration

    @duration.setter
    def duration(self, duration):
        self._duration = duration
        self.update_dash_objects()

    @property
    def description(self):
        """Return the description for this instance."""
        return self._description

    @description.setter
    def description(self, description):
        self._description = description
        self.update_dash_objects()

    @staticmethod
    def from_mne_annotation(annot, layout):
        """Create an EEGAnnotation instance from an mne.annotation."""
        return EEGAnnotation(annot["onset"],
                             annot["duration"],
                             annot["description"],
                             layout)

    def set_editable(self, editable=True):
        """Set the editable property of the layout.shape for this instance.

        Notes
        -----
        plotly graph_object.layout.shape objects that are editable can be
        moved/deleted/edited by the user by clicking the shape on a graph.
        """
        self._dash_shape["editable"] = editable
        self._dash_shape["opacity"] = 0.51


class EEGAnnotationList:
    """Instance to hold all EEGAnnotation instances."""

    def __init__(self, annotations=None):
        """Initialize instance.

        Parameters
        ----------
        annotations : EEGAnnotation | list | None
            The EEGAnnotation instances to store. Can be a single EEGANotation
            or a list of EEGAnnotation instances. If None, initializes class
            without any EEGAnnotations. Defaults to None.
        """
        if annotations is not None:
            if isinstance(annotations, list):
                self.annotations = pd.Series({annot.id: annot
                                              for annot in annotations})
            else:
                self.annotations = pd.Series(annotations)
        else:
            self.annotations = pd.Series()

    def __get_series(self, attr):
        return pd.Series({annot.id: getattr(annot, attr)
                          for annot in self.annotations.values})

    @property
    def durations(self):
        """Return duration for each EEGAnnotation."""
        return self.__get_series("duration")

    @property
    def onsets(self):
        """Return onset for each EEGAnnotation."""
        return self.__get_series("onset")

    @property
    def descriptions(self):
        """Return description for each EEGAnnotation."""
        return self.__get_series("description")

    @property
    def dash_shapes(self):
        """Return layout.shape of each EEGAnnotation."""
        return self.__get_series("dash_shape")

    @property
    def dash_descriptions(self):
        """Return layout.annotation of each EEGAnnotation.

        Notes
        -----
        plotly.graph_objects.layout.annotation objects hold the
        text of the annotation description that will be plotted to
        the graph.
        """
        return self.__get_series("dash_description")

    def pick(self, tmin=0, tmax=np.inf):
        """Pick EEGAnnotations within a range of time.

        Parameters
        ----------
        tmin : int | float
            the beginning of the time-window to return EEGAnnotations
            from, in seconds. If an EEGAnnotation object's onset occurs on or
            after tmin and before tmax, the EEGAnnotation will be returned.
            Defaults to 0.
        tmax : int | float | np.inf
            The end of the time-window to return EEGAnnotation object's from.
            If an EEGAnnotation object ends (onset + duration) on or before
            tmax, it will be returned so long as it's onset occurs on or after
            tmin. Defaults to np.inf, meaning that any annotations occur    ring
            after tmin will be returned.
        """
        annot_tmin = self.onsets
        annot_tmax = annot_tmin + self.durations

        mask = (((tmin <= annot_tmin) & (annot_tmin < tmax)) |
                ((tmin < annot_tmax) & (annot_tmax <= tmax)) |
                ((annot_tmin < tmin) & (annot_tmax > tmax))
                )
        return EEGAnnotationList(self.annotations[mask])

    def remove(self, id_):
        """Delete an EEGAnnotation."""
        self.annotations = self.annotations.drop(index=id_)

    @staticmethod
    def from_mne_inst(inst, layout):
        """Create EEGAnnotationList object from a list of mne.annotations."""
        annots = [EEGAnnotation.from_mne_annotation(annot, layout)
                  for annot in inst.annotations]
        return EEGAnnotationList(annots)

    def __len__(self):
        """Return the number of EEGAnnotations in this instance."""
        return len(self.annotations)

    def append(self, annot):
        """Add an EEGAnnotation to this instance."""
        self.annotations[annot.id] = annot

    def __setitem__(self, key, value):
        """Assign a new annotation to an EEGAnnotation in this instance."""
        self.annotations[key] = value

    def __getitem__(self, key):
        """Return EEGAnnotation instance."""
        return self.annotations[key]

    def __contains__(self, key):
        """Check if EEGAnnotation is in this instance."""
        return key in self.annotations

    def to_mne_annotation(self):
        """Convert all EEGAnnotations to mne.annotations."""
        return mne.Annotations(self.onsets, self.durations, self.descriptions)

    def set_editable(self, editable=True):
        """Set the editable property of a plotly.graph_objectslayout.shape.

        Parameters
        ----------
        editable : bool
            Whether the shape should be editable. Defaults to True.

        Notes
        -----
        plotly graph_object.layout.shape objects that are editable can be
        moved/deleted/edited by the user by clicking the shape on a graph.
        """
        for annot in self.annotations:
            annot.set_editable(editable)
        return self
